<!-- SPDX-FileCopyrightText: 2022 Dennis Gläser <dennis.glaeser@iws.uni-stuttgart.de> -->
<!-- SPDX-License-Identifier: GPL-3.0-or-later -->
<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GridFormat: Grid Traits</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GridFormat<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">I/O-Library for grid-like data structures</div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('grid-traits.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Grid Traits </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#mandatory-traits">Mandatory Traits</a></li>
<li class="level2"><a href="#traits-for-unstructured-grids">Traits for Unstructured Grids</a></li>
<li class="level2"><a href="#traits-for-structured-grids">Traits for Structured Grids</a></li>
<li class="level2"><a href="#traits-for-rectilinear-grids">Traits for Rectilinear Grids</a></li>
<li class="level2"><a href="#traits-for-image-grids">Traits for Image Grids</a></li>
<li class="level2"><a href="#optional-traits">Optional Traits</a></li>
<li class="level2"><a href="#notes-for-parallel-grids">Notes for Parallel Grids</a></li>
</ul>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_gridformat_gridformat_docs_pages_traits"></a></p>
<p><code>GridFormat</code> uses a traits (or meta-function) mechanism to operate on user-given grid types. As a motivating example, consider this piece of code:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>&gt;</div>
<div class="line"><span class="keywordtype">void</span> do_something_on_a_grid(<span class="keyword">const</span> <a class="code" href="group__Grid.html#ga733df58a3197824a355a4c24ba5bc902">Grid</a>&amp; grid) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.cells()) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Grid_html_ga733df58a3197824a355a4c24ba5bc902"><div class="ttname"><a href="group__Grid.html#ga733df58a3197824a355a4c24ba5bc902">GridFormat::Concepts::Grid</a></div><div class="ttdeci">concept Grid</div><div class="ttdoc">Concept a type that fulfills any of the grid interfaces.</div><div class="ttdef"><b>Definition:</b> concepts.hpp:93</div></div>
</div><!-- fragment --><p><code>do_something_on_a_grid</code> iterates over all cells of the grid, and you can imagine that it then goes on to compute some stuff. The point is that with this way of writing the function, it is only compatible with grids that have a public <code>cells()</code> function which returns something over which we can iterate. This function would thus be incompatible with user-defined grids that provide a different way of iterating over the cells. One possibility would be to require users to write an adapter, but then they possibly also have to adapt the cell type that the iterator yields, etc...</p>
<p>Instead, in <code>GridFormat</code>, any piece of code that operates on user grids is written in terms of traits, and the code above would turn into something like:</p>
<div class="fragment"><div class="line"><span class="comment">// forward declaration</span></div>
<div class="line"><span class="keyword">namespace </span>Traits { <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>&gt; <span class="keyword">struct </span>Cells; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>&gt;</div>
<div class="line"><span class="keywordtype">void</span> do_something_on_a_grid(<span class="keyword">const</span> <a class="code" href="group__Grid.html#ga733df58a3197824a355a4c24ba5bc902">Grid</a>&amp; grid) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : Traits::Cells&lt;Grid&gt;::get(grid)) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The code now expects that there exist a specialization of the <code>Cells</code> trait for the given grid. This allows users to specialize that trait for their grid data structure, thereby making it compatible with <code>GridFormat</code>. See the code below for an idea about how the traits specialization may look. For more details on this, please have a look at the resources referenced in the <a href="https://github.com/dglaeser/gridformat/blob/main">main readme</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gridformat/grid/traits.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>MyLibrary {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="group__Grid.html#ga733df58a3197824a355a4c24ba5bc902">Grid</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="comment">// returns a range over the grid elements</span></div>
<div class="line">    std::ranges::range <span class="keyword">auto</span> elements()<span class="keyword"> const </span>{ <span class="comment">/* ... */</span> }</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace MyLibrary</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>GridFormat::Traits {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Cells&lt;MyLibrary::<a class="code" href="group__Grid.html#ga733df58a3197824a355a4c24ba5bc902">Grid</a>&gt; {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> get(<span class="keyword">const</span> <a class="code" href="group__Grid.html#ga733df58a3197824a355a4c24ba5bc902">MyLibrary::Grid</a>&amp; grid) {</div>
<div class="line">        <span class="keywordflow">return</span> grid.elements();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace GridFormat::Traits</span></div>
</div><!-- fragment --><p>As discussed in our <a class="el" href="grid-concepts.html#md__home_runner_work_gridformat_gridformat_docs_pages_grid_concepts">overview over supported kinds of grids</a>, <code>GridFormat</code> understands the notion of unstructured, structured, rectilinear or image grids. The reason for this is that some file formats are designed for specific kinds of grids and can store the information on their topology in a space-efficient manner. To see which format assumes which kind of grid, see the <a href="https://dglaeser.github.io/gridformat/">API documentation</a>. In the code, there exist <a href="https://en.cppreference.com/w/cpp/language/constraints">concepts</a> for each of these kinds of grids, which essentially check if the required traits are correctly implemented. The remainder of this page discusses the different traits used by <code>GridFormat</code>, and which ones need to be specialized in order to model a particular kind of grid. In case you want to use <code>GridFormat</code> in parallel computations, please also make sure to read the related section at the end of this page. Note that all traits presented in the following are declared in the <code>namespace GridFormat::Traits</code>.</p>
<h2><a class="anchor" id="mandatory-traits"></a>
Mandatory Traits</h2>
<ul>
<li><code>template&lt;typename Grid&gt; struct Cells;</code></li>
</ul>
<p>This trait exposes how one can iterate over the cells of a grid. Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns a <a href="https://en.cppreference.com/w/cpp/ranges/forward_range">forward range</a> of cells.</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct Points;</code></li>
</ul>
<p>This trait exposes how one can iterate over the points of a grid. Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns a <a href="https://en.cppreference.com/w/cpp/ranges/forward_range">forward range</a> of points.</p>
<h2><a class="anchor" id="traits-for-unstructured-grids"></a>
Traits for Unstructured Grids</h2>
<ul>
<li><code>template&lt;typename Grid, typename Cell&gt; struct CellPoints;</code></li>
</ul>
<p>This trait exposes how one can iterate over the points of an individual grid cell. Specializations must provide a static function <code>get(const Grid&amp;, const Cell&amp;)</code> that returns a <a href="https://en.cppreference.com/w/cpp/ranges/range">range</a> of points that make up the boundary of the given cell.</p>
<ul>
<li><code>template&lt;typename Grid, typename Cell&gt; struct CellType;</code></li>
</ul>
<p>This trait exposes the geometry type of an individual grid cell. Specializations must provide a static function <code>get(const Grid&amp;, const Cell&amp;)</code> that returns an instance of the <a href="https://github.com/dglaeser/gridformat/blob/main/gridformat/grid/cell_type.hpp">CellType enum</a>.</p>
<ul>
<li><code>template&lt;typename Grid, typename Point&gt; struct PointCoordinates;</code></li>
</ul>
<p>This trait exposes the coordinates of a grid point. Specializations must provide a static function <code>get(const Grid&amp;, const Point&amp;)</code> that returns the coordinates of the given point as a <a href="#optional-traits">statically sized range</a>.</p>
<ul>
<li><code>template&lt;typename Grid, typename Point&gt; struct PointId;</code></li>
</ul>
<p>This trait exposes a unique id for individual points of a grid. Specializations must provide a static function <code>get(const Grid&amp;, const Point&amp;)</code> that returns a unique id (as integer value, e.g. <code>std::size_t</code>) for the given point.</p>
<h2><a class="anchor" id="traits-for-structured-grids"></a>
Traits for Structured Grids</h2>
<p>In addition to the traits below, the <code>StructuredGrid</code> concept also requires that the <code>PointCoordinates</code> trait is implemented (see above).</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct Extents;</code></li>
</ul>
<p>This trait exposes the number of cells of the structured grid in each coordinate direction. Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns a <a href="#optional-traits">statically sized range</a>, whose size is equal to the dimension of the grid.</p>
<ul>
<li><code>template&lt;typename Grid, typename Entity&gt; struct Location;</code></li>
</ul>
<p>This trait exposes the index tuple of a given entity within the structured grid. For a visualization and the assumptions on the orientation, see the <a href="https://github.com/dglaeser/gridformat/blob/feature/high-level-docs/docs/grid_kinds.md">overview over supported kinds of grids</a>. This trait must be specialized for both cells and points (i.e. for two types of <code>Entity</code>), and they must provide a static function <code>get(const Grid&amp;, const Entity&amp;)</code> that returns a <a href="#optional-traits">statically sized range</a> whose elements are integer values (the indices of the entity) and whose size is equal to the dimension of the grid.</p>
<h2><a class="anchor" id="traits-for-rectilinear-grids"></a>
Traits for Rectilinear Grids</h2>
<p>In addition to the <code>Ordinates</code> trait below, the <code>RectilinearGrid</code> concept also requires that the <code>Extents</code> and <code>Location</code> traits are implemented (see above).</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct Ordinates;</code></li>
</ul>
<p>This trait exposes the ordinates of a <code>RectilinearGrid</code> grid along the coordinate axes. Specializations must provide a static function <code>get(const Grid&amp;, unsigned int direction)</code> that returns a <a href="https://en.cppreference.com/w/cpp/ranges/range">range</a> over the ordinates along the axis specified by <code>direction</code> (<code>direction &lt; dim</code>, where dim is the dimension of the grid). The size of the range must be equal to the number of cells + 1 in the given direction.</p>
<h2><a class="anchor" id="traits-for-image-grids"></a>
Traits for Image Grids</h2>
<p>In addition to the traits below, the <code>ImageGrid</code> concept also requires that the <code>Extents</code> and <code>Location</code> traits are implemented (see above).</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct Origin;</code></li>
</ul>
<p>This trait exposes the position of the lower-left corner of the grid, that is, the position of the point at index \((0, 0, 0)\) (for a visualization see <a href="https://github.com/dglaeser/gridformat/blob/feature/high-level-docs/docs/grid_kinds.md">here</a>). Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns a <a href="#optional-traits">statically sized range</a>, whose size is equal to the dimension of the grid.</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct Spacing;</code></li>
</ul>
<p>This trait exposes the spacing between grid points along the axes (in other words, the size of the cells in each coordinate direction). Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns a <a href="#optional-traits">statically sized range</a>, whose size is equal to the dimension of the grid.</p>
<h2><a class="anchor" id="optional-traits"></a>
Optional Traits</h2>
<ul>
<li><code>template&lt;typename Grid&gt; struct NumberOfPoints;</code></li>
</ul>
<p>This trait exposes the number of points of a grid, and if not specialized, the number of points is deduced from the size of the range obtained from <code>Points</code>. If your point range is not a <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a>, however, specializing this trait can lead to an improved efficiency. Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns the number of points as an integral value.</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct NumberOfCells;</code></li>
</ul>
<p>This trait exposes the number of cells of a grid, and if not specialized, the number of cells is deduced from the size of the range obtained from <code>Cells</code>. If your cell range is not a <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a>, however, specializing this trait can lead to an improved efficiency. Specializations must provide a static function <code>get(const Grid&amp;)</code> that returns the number of cells as an integral value.</p>
<ul>
<li><code>template&lt;typename Grid, typename Cell&gt; struct NumberOfCellPoints;</code></li>
</ul>
<p>This trait exposes the number of points in a grid cell, and if not specialized, the number of points is deduced from the size of the range obtained from <code>CellsPoints</code>. If that range is not a <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a>, however, specializing this trait can lead to an improved efficiency. Specializations must provide a static function <code>get(const Grid&amp;, const Cell&amp;)</code> that returns the number of points in the cell as an integral value.</p>
<ul>
<li><code>template&lt;typename Grid&gt; struct Basis;</code></li>
</ul>
<p>This trait can be specified for image grids in order to specify their orientation. Per default, an image grid is assumed to be axis-aligned, that is, the default basis (in 3D) is</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> default_basis = std::array{</div>
<div class="line">    std::array{1.0, 0.0, 0.0},</div>
<div class="line">    std::array{0.0, 1.0, 0.0},</div>
<div class="line">    std::array{0.0, 0.0, 1.0},</div>
<div class="line">};</div>
</div><!-- fragment --><p>Specializing the <code>Basis</code> trait, you can implement the static function <code>get(const Grid&amp;)</code> and return a custom basis. It is expected that the return type from this function is a two-dimensional, <a href="#optional-traits">statically-sized range</a>, with the outer and inner dimensions being equal to the grid dimension.</p>
<ul>
<li><code>template&lt;typename T&gt; struct StaticSize;</code></li>
</ul>
<p><code>GridFormat</code> requires that the types returned from some traits model the <a href="https://github.com/dglaeser/gridformat/blob/feature/high-level-docs/gridformat/common/concepts.hpp#L25"><code>StaticallySizedRange</code> concept</a>. Statically sized means that the size of the <a href="https://en.cppreference.com/w/cpp/ranges/range">range</a> is known at compile time. Per default, <code>GridFormat</code> accepts <code>std::array</code>, <code>std::span</code> (with non-dynamic extent), <code>T[N]</code> or anything that either has a <code>constexpr static std::size_t size()</code> function or a member variable named <code>size</code> that can be evaluated at compile time. If your type does not fulfill any of these requirements, but is in fact range with a size known at compile-time, you can also specialize the <a href="https://github.com/dglaeser/gridformat/blob/main/gridformat/common/type_traits.hpp#L349"><code>StaticSize</code> trait</a> for the type you want to return. Alternatively, you can of course just convert your type into an <code>std::array</code> within the trait that expects you to return a statically sized range.</p>
<h2><a class="anchor" id="notes-for-parallel-grids"></a>
Notes for Parallel Grids</h2>
<p>In order to use <code>GridFormat</code> to write grid files from parallel computations using <a href="https://de.wikipedia.org/wiki/Message_Passing_Interface">MPI</a>, make sure that you implement the above traits such that they <b>only</b> return information on one <b>partition</b>. Moreover, <code>GridFormat</code> currently does not provide any means to flag cells/points as ghost or overlap entities, and therefore, it is expected that you only provide information on the collection of interior entities, that is, the partitions are expected to be disjoint. To be more concrete, it is expected that</p>
<ul>
<li>The <code>Cells</code> trait provides a range over the interior cells of a partition, only.</li>
<li>The <code>Points</code> trait provides a range over only those points that are connected to interior cells (otherwise there will be unconnected points in the output, however, it should still work).</li>
<li>The <code>Extents</code> trait provides the number of cells of the partition, <b>not</b> counting any ghosts or overlap cells.</li>
<li>The <code>Ordinates</code> trait provides the ordinates of the partition, <b>only</b> including points that are connected to interior cells.</li>
<li>The <code>Origin</code> trait returns the lower-left corner of the partition <b>without</b> ghost cells.</li>
</ul>
<p>If you include ghost entities in your traits, output should still work, but there will be overlapping cells. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- SPDX-FileCopyrightText: 2022 Dennis Gläser <dennis.glaeser@iws.uni-stuttgart.de> -->
<!-- SPDX-License-Identifier: GPL-3.0-or-later -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
